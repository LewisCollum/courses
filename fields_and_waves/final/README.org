#+latex_class: IEEEtran
#+property: header-args:python :results silent :eval no-export :exports none
#+property: header-args:bash :results drawer :eval no-export :exports none
#+options: num:t toc:t
#+bind: org-latex-image-default-width ".8\\linewidth"

#+title: Microstrip Antenna Arrays
#+author: Lewis Collum

#+begin_abstract
Hello
#+end_abstract

* Library :noexport:
** call_test
   #+name: test
   #+begin_src bash :var name="" :dir source :async
python -m unittest $name.py 2>&1
echo
   #+end_src

** conversion
   #+begin_src python :tangle source/conversion.py
import numpy
from numpy import pi, sin, cos, arccos, arctan2, sqrt
from collections import namedtuple

c = 2.99792458E8

def frequencyToWavelength(frequency):
    return c/frequency

def wavelengthToFrequency(wavelength):
    return c/wavelength

def waveNumber(wavelength):
    return 2*pi / wavelength

SphericalCoordinates = namedtuple('SphericalCoordinates', ['r', 'pitch', 'yaw'])
CartesianCoordinates = namedtuple('CartesianCoordinates', ['x', 'y', 'z'])

def sphericalToCartesian(r, yaw, pitch):
    x = r * cos(yaw) * sin(pitch)
    y = r * sin(yaw) * sin(pitch)
    z = r * cos(pitch)
    return CartesianCoordinates(x, y, z)

def cartesianToSpherical(x, y, z):
    r = sqrt(x**2 + y**2 + z**2)
    pitch = arccos(z / r)
    yaw = arctan2(y, x)
    return SphericalCoordinates(r, pitch, yaw)
  #+end_src  
** test_conversion
   #+begin_src python :tangle source/test_conversion.py
import unittest
import conversion as conv
import numpy
from numpy import pi, sqrt

class TestConversion(unittest.TestCase):
    def test_cartesianToSpherical_xOnly(self):
        actual = conv.cartesianToSpherical(1, 0, 0)
        expected = conv.SphericalCoordinates(r = 1, pitch = pi/2, yaw = 0)

        numpy.testing.assert_array_almost_equal(actual, expected)


    def test_cartesianToSpherical_yOnly(self):
        actual = conv.cartesianToSpherical(0, 1, 0)
        expected = conv.SphericalCoordinates(r = 1, pitch = pi/2, yaw = pi/2)

        numpy.testing.assert_array_almost_equal(actual, expected)


    def test_cartesianToSpherical_zOnly(self):
        actual = conv.cartesianToSpherical(0, 0, 1)
        expected = conv.SphericalCoordinates(r = 1, pitch = 0, yaw = 0)

        numpy.testing.assert_array_almost_equal(actual, expected)

        
    def test_cartesianToSpherical_each(self):
        actual = conv.cartesianToSpherical(sqrt(2)/2, -sqrt(2)/2, 0)
        expected = conv.SphericalCoordinates(r = 1, pitch = pi/2, yaw = -pi/4)

        numpy.testing.assert_array_almost_equal(actual, expected)
       

    def test_waveNumber_14Ghz(self):
        frequency = 14E9
        wavelength = conv.frequencyToWavelength(frequency)

        actual = conv.waveNumber(wavelength)
        expected = 2*pi / (conv.c/frequency)

        numpy.testing.assert_almost_equal(actual, expected)
         

if __name__ == '__main__':
    unittest.main()
   #+end_src
   #+call: test(name="test_conversion")

   #+RESULTS:
   :results:
   .....
   ----------------------------------------------------------------------
   Ran 5 tests in 0.002s

   OK

   :end:

** patch
   #+begin_src python :tangle source/patch.py
import numpy
from numpy import pi, sin, cos, sqrt
from collections import namedtuple
import conversion as conv
from matplotlib import pyplot
from mpl_toolkits.mplot3d import Axes3D

Patch = namedtuple('Patch', ['width', 'height', 'length', 'effectiveLength', 'waveNumber'])
Material = namedtuple('Material', ['relativePermittivity', 'height'])

class RadiationPlotter:
    def __init__(self, patchRadiation):
        self.radiation = patchRadiation

    def plotHPlane(self, fileName = None):
        hPlane = self.radiation.hPlane()
        figure = pyplot.figure(figsize=(4,3))
        axes = figure.add_subplot(111, projection='polar')
        axes.plot(hPlane.pitch, hPlane.r)
        axes.set_thetamax(180)
        axes.set_xlabel(r'$\theta$')
        figure.tight_layout()
        self.showOrSave(fileName)

    def plotEPlane(self, fileName = None):
        ePlane = self.radiation.ePlane()
        figure = pyplot.figure(figsize=(4,3))
        axes = figure.add_subplot(111, projection='polar')
        axes.plot(ePlane.yaw, ePlane.r)
        axes.set_thetamin(-90)
        axes.set_thetamax(90)
        axes.set_xlabel(r'$\phi$')        
        figure.tight_layout()
        self.showOrSave(fileName)

    def plotTotal(self, fileName = None):
        total = self.radiation.totalAsCartesian()
        figure = pyplot.figure(figsize=(5,4))
        axes = figure.add_subplot(111, projection='3d')        
        axes.plot_surface(total.z, total.y, total.x)
        axes.set_xlabel('z (along width)')
        axes.set_ylabel('y (along length)')
        axes.set_zlabel('x (along height)')
        figure.tight_layout()
        self.showOrSave(fileName)
        
    def showOrSave(self, fileName):
        if fileName:
            pyplot.savefig(fileName)
            pyplot.clf()
        else:
            pyplot.show()        
        
        
class PatchRadiation:
    def __init__(self, patch, resolution):
        self.patch = patch
        self.resolution = resolution        
        self.pitch = numpy.linspace(0, pi, resolution)
        self.yaw = numpy.linspace(-pi/2, pi/2, resolution)
 
    def hPlane(self):
        x = self.patch.waveNumber*self.patch.height/2 * sin(self.pitch)
        z = self.patch.waveNumber*self.patch.width/2 * cos(self.pitch)
        magnitudes = sin(self.pitch) * sin(x)/x * sin(z)/z
        return conv.SphericalCoordinates(
            r = magnitudes,
            yaw = 0,
            pitch = self.pitch)

    def ePlane(self):
        x = self.patch.waveNumber*self.patch.height/2 * cos(self.yaw)
        y = self.patch.waveNumber*self.patch.effectiveLength/2 * sin(self.yaw)
        magnitudes = cos(y) * sin(x)/x
        return conv.SphericalCoordinates(
            r = magnitudes,
            yaw = self.yaw,
            pitch = 90)
    
    def totalAsSpherical(self):
        ePlane, hPlane = numpy.meshgrid(self.ePlane().r, self.hPlane().r)
        yaw, pitch = numpy.meshgrid(self.yaw, self.pitch)
        radiation = ePlane * hPlane * self.rolloff(self.yaw, 0.5)
        return conv.SphericalCoordinates(
            r = numpy.nan_to_num(radiation),
            yaw = yaw,
            pitch = pitch)

    def totalAsCartesian(self):
        total = self.totalAsSpherical()
        x, y, z = conv.sphericalToCartesian(
            r = total.r,
            yaw = total.yaw,
            pitch = total.pitch)
        return conv.CartesianCoordinates(x, y, z)
        
    def rolloff(self, radians, factor):
        degrees = numpy.rad2deg(radians)
        F1 = 1 / (((factor*(abs(degrees) - 90))**2) + 0.001)
        return 1 / (F1 + 1)
       


class PatchBuilder:
    def __init__(self, material):
        self.eR = material.relativePermittivity
        self.height = material.height

    def buildForFrequency(self, frequency):
        self.setDimensionsFromFrequency(frequency)
        return Patch(
            width = self.width,
            length = self.lengthWithoutFringe,
            height = self.height,
            effectiveLength = self.lengthWithFringe,            
            waveNumber = conv.waveNumber(self.wavelength))


    def setDimensionsFromFrequency(self, frequency):
        self.wavelength = conv.frequencyToWavelength(frequency)
        self.width = self.widthFromWavelength(self.wavelength)
        widthToThicknessRatio = self.width/self.height
        
        eEff = self.effectiveRelativePermittivity(widthToThicknessRatio)
        self.lengthWithFringe = self.lengthEffective(self.wavelength, eEff)

        fringeExtension = self.fringeExtension(eEff, widthToThicknessRatio)
        self.lengthWithoutFringe = self.lengthWithFringe - 2*fringeExtension

        
    def widthFromWavelength(self, wavelength):
        return wavelength/2 * sqrt(2/(self.eR + 1))

    
    def effectiveRelativePermittivity(self, widthToThicknessRatio):
        linear = (self.eR + 1)/2
        coefficient = (self.eR - 1)/2
        nonlinear = (1 + 12/widthToThicknessRatio)**(-1/2)        
        return linear + coefficient*nonlinear

    
    def lengthEffective(self, wavelength, eEff):
        return wavelength/2/sqrt(eEff)

    
    def fringeExtension(self, eEff, widthToThicknessRatio):
        numerator = (eEff + 0.3)*(widthToThicknessRatio + 0.264)
        denominator = (eEff - 0.258)*(widthToThicknessRatio + 0.8)
        extension = 0.412 * self.height * numerator/denominator
        return extension

    @property
    def heightEffective(self):
        return self.height*sqrt(self.eR)

  #+end_src  
** test_patch
   #+begin_src python :tangle source/test_patch.py
import unittest
import patch as pt
import numpy
from numpy import pi, sqrt
import conversion as conv

class TestPatchBuilder(unittest.TestCase):
    def setUp(self):
        rtDuroid5880 = pt.Material(
            relativePermittivity = 2.2,
            height = 0.1588E-2)
        patchBuilder = pt.PatchBuilder(rtDuroid5880)
        
        self.patch = patchBuilder.buildForFrequency(10E9)
        self.radiation = pt.PatchRadiation(self.patch, resolution = 501)
        self.plotter = pt.RadiationPlotter(self.radiation)
        
    def test_rtDuroid5880Build_matchesBalanisTextbook(self):
        actual = self.patch
        expected = pt.Patch(
            width = 1.186E-2,
            height = 0.1588E-2,
            length = 0.906E-2,
            effectiveLength = 1.068E-2,
            waveNumber = conv.waveNumber(conv.frequencyToWavelength(10E9)))
            
        numpy.testing.assert_array_almost_equal(actual, expected, 3)

    def test_plotHPlane(self):
        self.plotter.plotHPlane('../figure/patch_hPlane.png')

    def test_plotEPlane(self):
        self.plotter.plotEPlane('../figure/patch_ePlane.png')

    def test_plotTotal(self):
        self.plotter.plotTotal('../figure/patch_total.png')

if __name__ == '__main__':
    unittest.main()
   #+end_src
   #+call: test(name="test_patch")

   #+RESULTS:
   :results:
   ./home/charon/course/fields_and_waves/final/source/patch.py:65: RuntimeWarning: invalid value encountered in true_divide
     magnitudes = sin(self.pitch) * sin(x)/x * sin(z)/z
   /usr/lib/python3.8/site-packages/matplotlib/projections/polar.py:55: RuntimeWarning: invalid value encountered in greater_equal
     r = np.where(r >= 0, r, np.nan)
   ...
   ----------------------------------------------------------------------
   Ran 4 tests in 0.666s

   OK

   :end:


* Single Patch Antenna: Physical Design
** Design Context
** Fringing Effects
   Fringing fields at the lengths of the patch makes the patch appear
   to have a greater length than it actually does. This is important
   since the effective dimensions of the patch affect the resonant
   frequency. If the physical length of the patch is \(L\), then the
   effective length, \(L_{\texttt{eff}}\), can be written as
   \[L_{\texttt{eff}} = L + \Delta L,\] where \(\Delta L\) is the
   additional length on one end of the patch.

   The additional length can be related to the width of the patch, \(W\) and
   the effective relative permittivity of the dieletric substrate,
   \(\epsilon_{\texttt{eff}}\), as

   #+begin_latex
   \begin{equation} \label{eq-dL}
     \dfrac{\Delta L}{h} = 0.412 \dfrac{
       (\epsilon_{\texttt{eff}}+0.3)\left(\dfrac{W}{h} + 0.264\right)}{
       (\epsilon_{\texttt{eff}}-0.258)\left(\dfrac{W}{h} + 0.8\right)}.
   \end{equation}
   #+end_latex

** Effective Relative Permittivity
   To find the effective relative permittivity, we use
   
   #+begin_latex
   \begin{equation} \label{eq-eEff}
     \epsilon_{\texttt{eff}} = \dfrac{\epsilon_{r}+1}{2}
     + \dfrac{\epsilon_r-1}{2}
     \left(1 + 12\cdot \frac{h}{W}\right)^{-1/2}.
   \end{equation}
   #+end_latex 

   
** Effective Length
** Physical Design Length
** Summary
* Single Patch Antenna: Radiation Pattern
** E-Plane
   [[./figure/patch_ePlane.png]]
** H-Plane
   [[./figure/patch_hPlane.png]]
** Far-Zone Total Electric Field
   [[./figure/patch_total.png]]
** Directivity
** Efficiency
** Summary
* N-Element Patch Array
** Coordinates
** Relative Phase
** Array Factor from Summed Elements
** Directivity
** Efficiency
** Summary
* Impedance Matching by Insetting the Feed-Point
** Input Impedance
** Inset Position
* Conclusion

* References :ignore:
  bibliographystyle:ieeetr
  bibliography:README.bib
  

* Source :noexport:

https://empossible.net/wp-content/uploads/2018/03/Topic-5-Microstrip-Patch-Antenna.pdf

http://www.elcom-hu.com/Electrical/Antennas%20/Antenna%20Theory%20Analysis%20and%20Design%20Cropped%20fixed%20Constantine%20A%20Balanis%202nd%20Ed%20John%20Will.pdf

* Talkables :noexport:
  - cavity model pg 746

*** TODO Make part 1 patch in inkscape (in Design Context)
*** TODO Math work-through 1hr
*** TODO Figure Captions 1hr
*** TODO Site book
