<!DOCTYPE html>
<html>
  <head>
    <title>Lab 4: Viewing & Lighting</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >    
    <script type="text/javascript" src="../Common/webgl-utils.js"></script>
    <script type="text/javascript" src="../Common/initShaders.js"></script>
    <script type="text/javascript" src="../Common/MV.js"></script>
    <script type="text/javascript" src="lab4.js"></script>
    <script type="text/javascript" src="object.js"></script>
    <script type="text/javascript" src="Drawer.js"></script>
    <script type="text/javascript" src="radial.js"></script>
    <script type="text/javascript" src="matrix.js"></script>
    <script type="text/javascript" src="vector.js"></script>    
    <script type="text/javascript" src="form.js"></script>
    <script type="text/javascript" src="frameEventDispatcher.js"></script>
    <script type="text/javascript" src="LightSwitch.js"></script>
    <script type="text/javascript" src="Camera.js"></script>
    <script type="text/javascript" src="viewBox.js"></script>        
    <link rel="stylesheet" href="style.css">
    
    <script id="vertex-shader" type="x-shader/x-vertex">
      precision mediump float;
      struct Camera {
          mat4 view;
          mat4 viewInverse;          
          mat4 projection;
      };

      attribute vec4 vertexPosition;
      attribute vec3 vertexNormal;
      uniform mat4 transformation;

      uniform Camera camera;

      varying vec4 transformedPosition;
      varying vec4 transformedNormal;
      void main() {
          gl_PointSize = 1.0;
          
          transformedPosition = camera.view * transformation * vertexPosition;
          gl_Position = camera.projection * transformedPosition;

          transformedNormal = transformation * vec4(vertexNormal, 1.0);         
      }
    </script>
    
    <script id="fragment-shader" type="x-shader/x-fragment">
      precision mediump float;

      struct Camera {
          mat4 view;
          mat4 viewInverse;          
          mat4 projection;
      };

      struct Colors {
          vec3 ambient;
          vec3 diffuse;
          vec3 specular;
      };

      struct FragmentDirection {
          vec3 toLight;
          vec3 toCamera;
          vec3 normal;
      };

      struct Falloff {
          float constant;
          float linear;
          float quadratic;
      };
      float falloffAtDistance(Falloff falloff, float distance) {
          return 1.0 / (falloff.constant +
                        falloff.linear * distance +
                        falloff.quadratic * pow(distance, 2.0));
      }
      
      struct PointLight {
          Colors colors;
          Falloff falloff;
          vec3 position;
          float shininess;
      };
      Colors colorsAtPositionFromPointLight(vec4 position, PointLight light) {
          float distance = length(light.position - position.xyz);
          float falloff = falloffAtDistance(light.falloff, distance);
          
          Colors colorsAtPosition;
          colorsAtPosition.ambient = light.colors.ambient * falloff;
          colorsAtPosition.diffuse = light.colors.diffuse * falloff;
          colorsAtPosition.specular = light.colors.specular * falloff;
          return colorsAtPosition;
      }        

      struct SpotLight {
          Colors colors;
          vec3 position;          
          vec4 direction;
          float angle;
      };
      
      uniform Camera camera;
      uniform PointLight lights[1];
      uniform SpotLight spotlights[1];
      float shininess = 4.0;
  
      varying vec4 transformedPosition;
      varying vec4 transformedNormal;
      void main() {
          FragmentDirection direction;          
          direction.toLight = normalize(lights[0].position - transformedPosition.xyz);
          direction.toCamera = normalize(-transformedPosition.xyz);
          direction.normal = normalize((camera.viewInverse * transformedNormal).xyz);

          float lambertian = max(dot(direction.toLight, direction.normal), 0.0);
          vec3 reflection = reflect(-direction.toLight, direction.normal);
          float directivity = dot(reflection, direction.toCamera);
          float shine = pow(max(directivity, 0.0), lights[0].shininess);
          
          //float dotFromDirection = dot(direction.toLight, -spotlights[0].direction);
          //float inLight = step(spotlights[0].limitAngle, dotFromDirection);
          //float light = inLight * dot(direction.normal, direction.toLight);

          Colors pointLightColors;
          pointLightColors = colorsAtPositionFromPointLight(transformedPosition, lights[0]);
          
          Colors colors = Colors(vec3(0.0), vec3(0.0), vec3(0.0));
          colors.ambient += pointLightColors.ambient;
          colors.diffuse += pointLightColors.diffuse * lambertian;
          if (lambertian > 0.0) {
              colors.specular += pointLightColors.specular * shine;
          }
          else {
              colors.specular = vec3(0.0);
          }

          vec3 clampedPhongSum = clamp(colors.diffuse + colors.ambient + colors.specular, 0.0, 1.0);
          gl_FragColor = vec4(clampedPhongSum, 1.0);
      }
    </script>
  </head>

  <body onload = "init()">
    <div class="container" id="cameraContainer">
      <form id="cameraPanel" class="sidepanel">
        <p>Projection</p>
        <ul id="projectionChoices"></ul>
        <p>Lights</p>
        <ul id="lightChoices"></ul>
        <p>Modifiers</p>
        <ul id="lightModifierChoices"></ul>
      </form>
      <button class="openbtn" id="cameraPanelButton">&#9776;</button>
      <canvas id="gl-canvas" height="512" width="512"></canvas>
      <div class="bottom-left">FPS: <span id="fps"></span></div>
    </div>
  </body>

  <script>
    var choiceCount = 0;
    function generateChoice(label, inputType, subType="") {
        var choice = document.createElement("li");
        choice.setAttribute("id", `li_${label}${subType}`)
        choice.innerHTML = `<input type=${inputType} value='${label}${subType}' name='${inputType}${subType}' id='${label}${subType}'/>
              <label for='${label}${subType}'>${label}</label>`
        choiceCount += 1
        return choice
    }

    function labelsToChoices(labels, inputType, subType="") {
        var choices = []
        labels.forEach((label) => {
            choices.push(generateChoice(label, inputType, subType))
        })
        return choices
    }

    function choicesToElementChildren(choices, element) {
        choices.forEach((choice) => {
            element.appendChild(choice)
        })
    }

    var currentProjection = null
    var checkedLights = new Set()
    var checkedModifiers = new Set()
    
    var projectionChoicesContainer = document.getElementById("projectionChoices")
    var projectionLabels = ['Parallel', 'Perspective']
    var projectionChoices = labelsToChoices(projectionLabels, "radio")
    projectionChoices.forEach((choice) => {
        projectionChoicesContainer.appendChild(choice)
    })

    var lightChoicesContainer = document.getElementById("lightChoices")        
    var lightLabels = ['Spot', 'Point']
    var lightChoices = labelsToChoices(lightLabels, "checkbox", "_light")
    lightChoices.forEach((choice) => {
        lightChoicesContainer.appendChild(choice)
    })

    var lightChoicesContainer = document.getElementById("lightModifierChoices")        
    var lightLabels = ['Specular']
    var lightChoices = labelsToChoices(lightLabels, "checkbox", "_lightModifier")
    lightChoices.forEach((choice) => {
        lightChoicesContainer.appendChild(choice)
    })

    
    var selectionSubject = {
        observers: [],
        addObserver: function(observer) {
            this.observers.push(observer)
        },
        notify: function(selection) {
            this.observers.forEach((observer) => {
                observer(selection)
            })
        },
        initialize: function(selection) {
            selection.lights.forEach((light) => {
                var lightElement = document.getElementById(`${light}_light`)
                lightElement.checked = true
                checkedLights.add(light)                    
            })
            selection.modifiers.forEach((modifier) => {
                var modifierElement = document.getElementById(`${modifier}_lightModifier`)
                modifierElement.checked = true
                checkedModifiers.add(modifier)                    
            })                
            
            var currentProjectionElement = document.getElementById(selection.projection)
            currentProjectionElement.checked = true
            currentProjection = currentProjectionElement.value
            
            this.notify(selection)
        }
    }        
    
    document.forms.cameraPanel.addEventListener('change', function(event) {
        if(event.target.name === 'radio') {
            currentProjection = event.target.value
        }
        else if (event.target.name === 'checkbox_light') {
            let value = event.target.value
            let light = value.split("_")[0]
            let type = value.split("_")[1]                  
            
            if (checkedLights.has(light)) checkedLights.delete(light)
            else checkedLights.add(light)
        }
        else if (event.target.name === 'checkbox_lightModifier') {
            let value = event.target.value
            let modifier = value.split("_")[0]
            let type = value.split("_")[1]
            
            if (checkedModifiers.has(modifier)) checkedModifiers.delete(modifier)
            else checkedModifiers.add(modifier)
        }

        selectionSubject.notify({
            projection: currentProjection,
            lights: checkedLights,
            modifiers: checkedModifiers
        })
    });
    
    var panel = document.getElementById("cameraPanel")
    panel.addEventListener('click', (event) => event.stopPropagation())
    
    var cameraPanelButton = document.getElementById("cameraPanelButton")
    cameraPanelButton.addEventListener('click', (event) => {
        event.stopPropagation()
        panel.style.width = "100px"
    })

    document.addEventListener('click', () => panel.style.width = "0")
  </script>
  
</html>
